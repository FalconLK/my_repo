{"repo":"litestar-org/litestar","pull_number":168,"instance_id":"litestar-org__litestar-168","issue_numbers":["167"],"base_commit":"7211dee1db3ac347b83e5199c6b89606251fffa7","patch":"diff --git a/starlite/app.py b/starlite/app.py\n--- a/starlite/app.py\n+++ b/starlite/app.py\n@@ -283,7 +283,7 @@ def default_http_exception_handler(self, request: Request, exc: Exception) -> St\n             server_middleware = ServerErrorMiddleware(app=self)\n             return server_middleware.debug_response(request=request, exc=exc)\n         if isinstance(exc, HTTPException):\n-            content = {\"detail\": exc.detail, \"extra\": exc.extra}\n+            content = {\"detail\": exc.detail, \"extra\": exc.extra, \"status_code\": exc.status_code}\n         elif isinstance(exc, StarletteHTTPException):\n             content = {\"detail\": exc.detail}\n         else:\ndiff --git a/starlite/openapi/responses.py b/starlite/openapi/responses.py\n--- a/starlite/openapi/responses.py\n+++ b/starlite/openapi/responses.py\n@@ -125,7 +125,9 @@ def create_error_responses(exceptions: List[Type[HTTPException]]) -> Iterator[Tu\n                 properties=dict(\n                     status_code=Schema(type=OpenAPIType.INTEGER),\n                     detail=Schema(type=OpenAPIType.STRING),\n-                    extra=Schema(type=OpenAPIType.OBJECT, additionalProperties=Schema()),\n+                    extra=Schema(\n+                        type=[OpenAPIType.NULL, OpenAPIType.OBJECT, OpenAPIType.ARRAY], additionalProperties=Schema()\n+                    ),\n                 ),\n                 description=pascal_case_to_text(get_name(exc)),\n                 examples=[{\"status_code\": status_code, \"detail\": HTTPStatus(status_code).phrase, \"extra\": {}}],\n","test_patch":"diff --git a/tests/app/test_error_handling.py b/tests/app/test_error_handling.py\n--- a/tests/app/test_error_handling.py\n+++ b/tests/app/test_error_handling.py\n@@ -27,6 +27,40 @@ def test_default_handle_http_exception_handling() -> None:\n     assert json.loads(response.body) == {\n         \"detail\": \"starlite_exception\",\n         \"extra\": {\"key\": \"value\"},\n+        \"status_code\": 500,\n+    }\n+\n+    response = Starlite(route_handlers=[]).default_http_exception_handler(\n+        Request(scope={\"type\": \"http\", \"method\": \"GET\"}),\n+        HTTPException(detail=\"starlite_exception\"),\n+    )\n+    assert response.status_code == HTTP_500_INTERNAL_SERVER_ERROR\n+    assert json.loads(response.body) == {\n+        \"detail\": \"starlite_exception\",\n+        \"extra\": None,\n+        \"status_code\": 500,\n+    }\n+\n+    response = Starlite(route_handlers=[]).default_http_exception_handler(\n+        Request(scope={\"type\": \"http\", \"method\": \"GET\"}),\n+        HTTPException(detail=\"starlite_exception\", extra=None),\n+    )\n+    assert response.status_code == HTTP_500_INTERNAL_SERVER_ERROR\n+    assert json.loads(response.body) == {\n+        \"detail\": \"starlite_exception\",\n+        \"extra\": None,\n+        \"status_code\": 500,\n+    }\n+\n+    response = Starlite(route_handlers=[]).default_http_exception_handler(\n+        Request(scope={\"type\": \"http\", \"method\": \"GET\"}),\n+        HTTPException(detail=\"starlite_exception\", extra=[\"extra-1\", \"extra-2\"]),\n+    )\n+    assert response.status_code == HTTP_500_INTERNAL_SERVER_ERROR\n+    assert json.loads(response.body) == {\n+        \"detail\": \"starlite_exception\",\n+        \"extra\": [\"extra-1\", \"extra-2\"],\n+        \"status_code\": 500,\n     }\n \n     response = Starlite(route_handlers=[]).default_http_exception_handler(\ndiff --git a/tests/test_template.py b/tests/test_template.py\n--- a/tests/test_template.py\n+++ b/tests/test_template.py\n@@ -52,7 +52,7 @@ def invalid_path() -> Template:\n     ) as client:\n         response = client.request(\"GET\", \"/\")\n         assert response.status_code == 500\n-        assert response.json() == {\"detail\": \"Template invalid.html not found.\", \"extra\": None}\n+        assert response.json() == {\"detail\": \"Template invalid.html not found.\", \"extra\": None, \"status_code\": 500}\n \n \n def test_mako_template(tmpdir: Any) -> None:\n@@ -101,7 +101,7 @@ def invalid_path() -> Template:\n     ) as client:\n         response = client.request(\"GET\", \"/\")\n         assert response.status_code == 500\n-        assert response.json() == {\"detail\": \"Template invalid.html not found.\", \"extra\": None}\n+        assert response.json() == {\"detail\": \"Template invalid.html not found.\", \"extra\": None, \"status_code\": 500}\n \n \n def test_handler_raise_for_no_template_engine() -> None:\n@@ -112,7 +112,7 @@ def invalid_path() -> Template:\n     with create_test_client(route_handlers=[invalid_path]) as client:\n         response = client.request(\"GET\", \"/\")\n         assert response.status_code == 500\n-        assert response.json() == {\"detail\": \"Template engine is not configured\", \"extra\": None}\n+        assert response.json() == {\"detail\": \"Template engine is not configured\", \"extra\": None, \"status_code\": 500}\n \n \n def test_template_with_no_context(tmpdir: Any) -> None:\n","problem_statement":"OpenAPI schema generation includes `status_code` but default exception handler never outputs that attribute\nI was doing some endpoint schema validation for my project and ran into what seems like an inconsistency between the generated OpenAPI schema and reality.\r\n\r\nSpecifically, `HTTPException` has an (optional) `status_code` attribute which is typically set to the response status code when something exceptional happens.\r\nThe fact that this field should always be present in the output is documented in the generated schema, but in the code it is omitted in all cases in the default exception handler:\r\n```py\r\nif isinstance(exc, HTTPException):\r\n    content = {\"detail\": exc.detail, \"extra\": exc.extra}\r\n```\r\n\r\nThis currently makes my tests fail because the schema says status_code is required, but starlite will never output it.\r\n\r\nThere are two possible fixes for this:\r\n1. Fix the OpenAPI schema generator not to include the field as required (or at all)\r\n2. Update the default exception handler to include the field when it exists\n","hints_text":"So, whats your suggestion for a fix?\n\nI would go with updating the error handler. \n\nIf you want, add a PR\nPersonally I would go with option 2 because:\r\n- The status codes are already tracked and it's documented in all schemas that Starlite has generated up until now, so this would break the \"API\" less in the sense that the OpenAPI schema just becomes more truthful instead of changing.\r\n- The status code is always given in `HTTPException` (500 by default) so we can simply add the field in the default exception handler and fix this very easily. It will be 500 when not otherwise specified and if it *is* specified, it'll be whatever the developer put in, which is expected behavior based on the rest of Starlite.","created_at":1655984717000,"PASS_TO_PASS":[],"FAIL_TO_PASS":[],"version":"litestar-org__litestar_1","FAIL_TO_FAIL":[],"spec_dict":{"python":"3.9","test_cmd":"pytest --tb=short --json-report --json-report-file=/pass_report.json -W ignore::DeprecationWarning","pip_packages":["asgiref==3.8.1","attrs==25.1.0","black==25.1.0","certifi==2025.1.31","charset-normalizer==2.0.12","click==8.1.8","coverage==7.6.12","exceptiongroup==1.2.2","exrex==0.12.0","faker==36.1.1","freezegun==1.2.1","ghp-import==2.1.0","greenlet==3.1.1","h11==0.14.0","hypothesis==6.36.0","idna==3.10","iniconfig==2.0.0","jinja2==3.1.5","mako==1.2.1","markdown==3.7","markdown-it-py==3.0.0","markupsafe==3.0.2","mdurl==0.1.2","mergedeep==1.3.4","mkdocs==1.6.1","mkdocs-get-deps==0.2.0","mkdocs-material==8.1.7","mkdocs-material-extensions==1.3.1","mypy==1.4.0","mypy-extensions==1.0.0","openapi-schema-pydantic==1.2.1","orjson==3.6.5","packaging==24.2","pathspec==0.12.1","pip==25.0.1","platformdirs==4.3.6","pluggy==1.5.0","py==1.11.0","pydantic==1.9.0","pydantic-factories==1.2.1","pygments==2.19.1","pymdown-extensions==10.14.3","pytest==7.0.0rc1","pytest-asyncio==0.17.2","pytest-cov==3.0.0","pytest-mock==3.10.0","python-dateutil==2.9.0.post0","python-multipart==0.0.5","pyyaml==6.0","pyyaml-env-tag==0.1","requests==2.27.1","rich==13.9.4","setuptools==75.8.2","six==1.17.0","sniffio==1.3.1","sortedcontainers==2.4.0","sqlalchemy==1.4.30","sqlalchemy2-stubs==0.0.2a38","starlette==0.17.1","tomli==2.2.1","typing-extensions==4.0.1","tzdata==2025.1","urllib3==1.26.20","uvicorn==0.17.0","watchdog==6.0.0","wheel==0.45.1"]}}
{"repo":"encode/httpx","pull_number":2495,"instance_id":"encode__httpx-2495","issue_numbers":["2491"],"base_commit":"563a1031f5bd37445d2fdbf622ba5cab926207c9","patch":"diff --git a/httpx/_content.py b/httpx/_content.py\n--- a/httpx/_content.py\n+++ b/httpx/_content.py\n@@ -114,7 +114,11 @@ def encode_content(\n         headers = {\"Content-Length\": str(content_length)} if body else {}\n         return headers, ByteStream(body)\n \n-    elif isinstance(content, Iterable):\n+    elif isinstance(content, Iterable) and not isinstance(content, dict):\n+        # `not isinstance(content, dict)` is a bit oddly specific, but it\n+        # catches a case that's easy for users to make in error, and would\n+        # otherwise pass through here, like any other bytes-iterable,\n+        # because `dict` happens to be iterable. See issue #2491.\n         content_length_or_none = peek_filelike_length(content)\n \n         if content_length_or_none is None:\n","test_patch":"diff --git a/tests/test_content.py b/tests/test_content.py\n--- a/tests/test_content.py\n+++ b/tests/test_content.py\n@@ -360,6 +360,9 @@ def test_invalid_argument():\n     with pytest.raises(TypeError):\n         httpx.Request(method, url, content=123)  # type: ignore\n \n+    with pytest.raises(TypeError):\n+        httpx.Request(method, url, content={\"a\": \"b\"})  # type: ignore\n+\n \n @pytest.mark.asyncio\n async def test_multipart_multiple_files_single_input_content():\n","problem_statement":"AsyncClient.request runtime error: \"Attempted to send an sync request with an AsyncClient instance\"\nRan into this issue as well. It was surprising to end up with a `RuntimeError: Attempted to send an sync request with an AsyncClient instance` error, when my actual issue had nothing to do with sync/async (in my case submitting the wrong type by accident through `data` kwarg). It feels like it might be a bug / that the type being submitted could be checked before trying to send the request?\r\n\r\n### Discussed in https://github.com/encode/httpx/discussions/2339\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **mdlincoln** August 16, 2022</sup>\r\nI need to interact with an API that accepts `DELETE` requests requiring JSON content in the body. Since `AsyncClient`'s shortcut `delete()` method does not allow this, I followed the docs to instead use the `request()` method, but I received an unexpected error. Minimal example:\r\n\r\n``` py\r\nimport asyncio\r\nfrom httpx import AsyncClient\r\n\r\nasync_client = AsyncClient(\r\n    base_url=\"http://localhost\",\r\n)\r\n\r\nasync def test_request_method():\r\n    async with async_client as ac:\r\n        response = await ac.request(method=\"DELETE\", url=\"/\", content={\"foo\": \"bar\"})\r\n\r\nasyncio.run(test_request_method())\r\n```\r\n\r\nthis raises a `RuntimeError: Attempted to send an sync request with an AsyncClient instance.` (full traceback in the `<details>` below.)\r\n\r\nAm I missing the right way for calling the `request()` method with an `AsyncClient`?\r\n\r\n<details>\r\n<pre>\r\nTraceback (most recent call last):\r\n  File \"*******/minimal.py\", line 14, in <module>\r\n    asyncio.run(test_request_method())\r\n  File \"/opt/homebrew/Cellar/python@3.9/3.9.13_3/Frameworks/Python.framework/Versions/3.9/lib/python3.9/asyncio/runners.py\", line 44, in run\r\n    return loop.run_until_complete(main)\r\n  File \"/opt/homebrew/Cellar/python@3.9/3.9.13_3/Frameworks/Python.framework/Versions/3.9/lib/python3.9/asyncio/base_events.py\", line 647, in run_until_complete\r\n    return future.result()\r\n  File \"*********minimal.py\", line 11, in test_request_method\r\n    response = await ac.request(method=\"DELETE\", url=\"/\", content={\"foo\": \"bar\"})\r\n  File \"*********/lib/python3.9/site-packages/httpx/_client.py\", line 1527, in request\r\n    return await self.send(request, auth=auth, follow_redirects=follow_redirects)\r\n  File \"*********/lib/python3.9/site-packages/httpx/_client.py\", line 1614, in send\r\n    response = await self._send_handling_auth(\r\n  File \"*********/lib/python3.9/site-packages/httpx/_client.py\", line 1642, in _send_handling_auth\r\n    response = await self._send_handling_redirects(\r\n  File \"*********/lib/python3.9/site-packages/httpx/_client.py\", line 1679, in _send_handling_redirects\r\n    response = await self._send_single_request(request)\r\n  File \"*********/lib/python3.9/site-packages/httpx/_client.py\", line 1711, in _send_single_request\r\n    raise RuntimeError(\r\nRuntimeError: Attempted to send an sync request with an AsyncClient instance.\r\n</pre>\r\n</details>\r\n</div>\n","hints_text":"> I need to interact with an API that accepts DELETE requests requiring JSON content in the body.\r\n\r\nThat's a really confusing error message that you're seeing, which I need to dig into.\r\n\r\nBut the short answer to your question is...\r\n\r\n> \"I need to interact with an API that accepts DELETE requests requiring JSON content in the body.\"\r\n\r\nOkay, so use `json=...` to send JSON data...\r\n\r\n```python\r\nawait ac.request(method=\"DELETE\", url=\"/\", json={\"foo\": \"bar\"})\r\n```\nTo improve our UX here we ought to be raising a `TypeError` if a dictionary is passed in the `content=...` argument.\r\nBecause it *won't do what you're expecting it to do*.\r\n\r\nIn the async case you'll end up with this really confusing error message.\r\n\r\nIn the sync case, you'll end up with...\r\n\r\n```python\r\n# Not ideal. We've treated the argument as valid, and attempted to send a request with content \"foo\".\r\n>>> httpx.post(\"https://www.example.com\", content={\"foo\": \"bar\"})\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_api.py\", line 304, in post\r\n    return request(\r\n           ^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_api.py\", line 100, in request\r\n    return client.request(\r\n           ^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_client.py\", line 821, in request\r\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_client.py\", line 908, in send\r\n    response = self._send_handling_auth(\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_client.py\", line 936, in _send_handling_auth\r\n    response = self._send_handling_redirects(\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_client.py\", line 973, in _send_handling_redirects\r\n    response = self._send_single_request(request)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_client.py\", line 1009, in _send_single_request\r\n    response = transport.handle_request(request)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_transports/default.py\", line 218, in handle_request\r\n    resp = self._pool.handle_request(req)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py\", line 253, in handle_request\r\n    raise exc\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py\", line 237, in handle_request\r\n    response = connection.handle_request(request)\r\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/venv/lib/python3.11/site-packages/httpcore/_sync/connection.py\", line 90, in handle_request\r\n    return self._connection.handle_request(request)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/venv/lib/python3.11/site-packages/httpcore/_sync/http11.py\", line 112, in handle_request\r\n    raise exc\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/venv/lib/python3.11/site-packages/httpcore/_sync/http11.py\", line 82, in handle_request\r\n    self._send_request_body(**kwargs)\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/venv/lib/python3.11/site-packages/httpcore/_sync/http11.py\", line 135, in _send_request_body\r\n    self._send_event(event, timeout=timeout)\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/venv/lib/python3.11/site-packages/httpcore/_sync/http11.py\", line 142, in _send_event\r\n    bytes_to_send = self._h11_state.send(event)\r\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/venv/lib/python3.11/site-packages/h11/_connection.py\", line 516, in send\r\n    return b\"\".join(data_list)\r\n           ^^^^^^^^^^^^^^^^^^^\r\nTypeError: sequence item 1: expected a bytes-like object, str found\r\n```\r\n\r\nThis is because `content=...` should be a str, bytes, or bytes iterator. Because `dict` instances *happen* to be iterators, the internals assume a bytes-iterator has been passed, and treat it as a valid argument.\r\n\r\nReally we'd like the same behaviour that we currently have if you pass some *other* incorrect type to `content=...`, eg:\r\n\r\n```python\r\n# Look, this error message makes sense...\r\n>>> httpx.post(\"https://www.example.com\", content=123)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_api.py\", line 304, in post\r\n    return request(\r\n           ^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_api.py\", line 100, in request\r\n    return client.request(\r\n           ^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_client.py\", line 808, in request\r\n    request = self.build_request(\r\n              ^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_client.py\", line 360, in build_request\r\n    return Request(\r\n           ^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_models.py\", line 339, in __init__\r\n    headers, stream = encode_request(\r\n                      ^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_content.py\", line 205, in encode_request\r\n    return encode_content(content)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_content.py\", line 130, in encode_content\r\n    raise TypeError(f\"Unexpected type for 'content', {type(content)!r}\")\r\nTypeError: Unexpected type for 'content', <class 'int'>\r\n```\r\n\r\nIt would be good if we switch the behaviour for the `dict` case to match this...\r\n\r\n```python\r\n# This would be a neater behaviour...\r\n>>> httpx.post(\"https://www.example.com\", content={\"a\": \"b\"})\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_api.py\", line 304, in post\r\n    return request(\r\n           ^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_api.py\", line 100, in request\r\n    return client.request(\r\n           ^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_client.py\", line 808, in request\r\n    request = self.build_request(\r\n              ^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_client.py\", line 360, in build_request\r\n    return Request(\r\n           ^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_models.py\", line 339, in __init__\r\n    headers, stream = encode_request(\r\n                      ^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_content.py\", line 205, in encode_request\r\n    return encode_content(content)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/Users/tomchristie/GitHub/encode/httpx/httpx/_content.py\", line 130, in encode_content\r\n    raise TypeError(f\"Unexpected type for 'content', {type(content)!r}\")\r\nTypeError: Unexpected type for 'content', <class 'dict'>\r\n```","created_at":"2022-12-06T16:47:24Z","PASS_TO_PASS":[],"FAIL_TO_PASS":[],"spec_dict":{"python":"3.9","pip_packages":["rfc3986[idna2008]<2,>=1.3","httpcore<0.15.0,>=0.14.5","socksio==1.*","h2<5,>=3","rich<13,>=10","hpack<5,>=4.1","hyperframe<7,>=6.1","anyio==3.*","h11<0.13,>=0.11","commonmark<0.10.0,>=0.9.0","hstspreload","brotli","pytest-cov","chardet==5.0.0","types-chardet==5.0.3","mkdocs==1.4.0","mkautodoc==0.2.0","mkdocs-material==8.5.5","build==0.8.0","twine==4.0.1","autoflake==1.4","black==22.8.0","coverage==6.4.4","cryptography==38.0.1","flake8==3.9.2","flake8-bugbear==22.7.1","importlib-metadata==4.13.0","isort==5.10.1","mypy==0.971","types-certifi==2021.10.8.2","pytest==7.1.2","pytest-asyncio==0.19.0","pytest-trio==0.7.0","trio==0.21.0","trio-typing==0.7.0","trustme==0.9.0","uvicorn==0.18.3"],"install":"pip install -e .[brotli,cli,http2,socks,zstd]","test_cmd":"pytest --tb=short --json-report --json-report-file=/pass_report.json -W ignore::DeprecationWarning"}}
