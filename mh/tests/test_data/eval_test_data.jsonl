{"repo":"encode/httpx","pull_number":1002,"instance_id":"encode__httpx-1002","issue_numbers":["822"],"base_commit":"21d7e16559d9360ae3a5c5cfd23bab8bb85ee4a8","patch":"diff --git a/httpx/_client.py b/httpx/_client.py\n--- a/httpx/_client.py\n+++ b/httpx/_client.py\n@@ -322,6 +322,10 @@ def redirect_url(self, request: Request, response: Response) -> URL:\n \n         url = URL(location, allow_relative=True)\n \n+        # Check that we can handle the scheme\n+        if url.scheme and url.scheme not in (\"http\", \"https\"):\n+            raise InvalidURL(f'Scheme \"{url.scheme}\" not supported.')\n+\n         # Handle malformed 'Location' headers that are \"absolute\" form, have no host.\n         # See: https://github.com/encode/httpx/issues/771\n         if url.scheme and not url.host:\n","test_patch":"diff --git a/tests/client/test_redirects.py b/tests/client/test_redirects.py\n--- a/tests/client/test_redirects.py\n+++ b/tests/client/test_redirects.py\n@@ -8,6 +8,7 @@\n from httpx import (\n     URL,\n     AsyncClient,\n+    InvalidURL,\n     NotRedirectResponse,\n     RequestBodyUnavailable,\n     TooManyRedirects,\n@@ -140,6 +141,17 @@ async def body():\n             else:\n                 return b\"HTTP/1.1\", 200, b\"OK\", [], ByteStream(b\"Hello, world!\")\n \n+        elif path == b\"/redirect_custom_scheme\":\n+            status_code = codes.MOVED_PERMANENTLY\n+            headers = [(b\"location\", b\"market://details?id=42\")]\n+            return (\n+                b\"HTTP/1.1\",\n+                status_code,\n+                b\"Moved Permanently\",\n+                headers,\n+                ByteStream(b\"\"),\n+            )\n+\n         return b\"HTTP/1.1\", 200, b\"OK\", [], ByteStream(b\"Hello, world!\")\n \n \n@@ -431,3 +443,11 @@ async def test_redirect_cookie_behavior():\n     response = await client.get(\"https://example.com/\")\n     assert response.url == \"https://example.com/\"\n     assert response.text == \"Not logged in\"\n+\n+\n+@pytest.mark.usefixtures(\"async_environment\")\n+async def test_redirect_custom_scheme():\n+    client = AsyncClient(dispatch=MockDispatch())\n+    with pytest.raises(InvalidURL) as e:\n+        await client.post(\"https://example.org/redirect_custom_scheme\")\n+    assert str(e.value) == 'Scheme \"market\" not supported.'\n","problem_statement":"KeyError occurs when redirect to custom scheme(ex. market://)\n# Information\r\n\r\nOS platform : mac OS\r\nPython version : 3.7.2\r\nInstalled dependencies and versions : `httpx==0.9.3`\r\nCode snippet\r\n```\r\n    @property\r\n    def port(self) -> int:\r\n        port = self._uri_reference.port\r\n        if port is None:\r\n            return {\"https\": 443, \"http\": 80}[self.scheme]\r\n        return int(port)\r\n```\r\n\r\nError traceback\r\n```\r\n[2020-02-24 14:57:08 +0900] [82150] [ERROR] Exception\r\nTraceback (most recent call last):\r\n  File \"/Users/sym/.pyenv/versions/airbridge-ads-was/lib/python3.7/site-packages/sanic/testing.py\", line 120, in _collect_response\r\n    method, url, *request_args, **request_kwargs\r\n  File \"/Users/sym/.pyenv/versions/airbridge-ads-was/lib/python3.7/site-packages/sanic/testing.py\", line 41, in _local_request\r\n    url, verify=False, *args, **kwargs\r\n  File \"/Users/sym/.pyenv/versions/airbridge-ads-was/lib/python3.7/site-packages/httpx/client.py\", line 671, in get\r\n    trust_env=trust_env,\r\n  File \"/Users/sym/.pyenv/versions/airbridge-ads-was/lib/python3.7/site-packages/httpx/client.py\", line 268, in request\r\n    trust_env=trust_env,\r\n  File \"/Users/sym/.pyenv/versions/airbridge-ads-was/lib/python3.7/site-packages/httpx/client.py\", line 410, in send\r\n    allow_redirects=allow_redirects,\r\n  File \"/Users/sym/.pyenv/versions/airbridge-ads-was/lib/python3.7/site-packages/httpx/client.py\", line 478, in send_handling_redirects\r\n    request = self.build_redirect_request(request, response)\r\n  File \"/Users/sym/.pyenv/versions/airbridge-ads-was/lib/python3.7/site-packages/httpx/client.py\", line 500, in build_redirect_request\r\n    headers = self.redirect_headers(request, url, method)\r\n  File \"/Users/sym/.pyenv/versions/airbridge-ads-was/lib/python3.7/site-packages/httpx/client.py\", line 555, in redirect_headers\r\n    if url.origin != request.url.origin:\r\n  File \"/Users/sym/.pyenv/versions/airbridge-ads-was/lib/python3.7/site-packages/httpx/models.py\", line 215, in origin\r\n    return Origin(self)\r\n  File \"/Users/sym/.pyenv/versions/airbridge-ads-was/lib/python3.7/site-packages/httpx/models.py\", line 287, in __init__\r\n    self.port = url.port\r\n  File \"/Users/sym/.pyenv/versions/airbridge-ads-was/lib/python3.7/site-packages/httpx/models.py\", line 165, in port\r\n    return {\"https\": 443, \"http\": 80}[self.scheme]\r\nKeyError: 'market'\r\n[2020-02-24 14:57:08 +0900] [82150] [INFO] Starting worker [82150]\r\n[2020-02-24 14:57:08 +0900] [82150] [INFO] Stopping worker [82150]\r\n[2020-02-24 14:57:08 +0900] [82150] [INFO] Server Stopped\r\n```\r\n\r\n# Description\r\ni'm using sanic and sanic uses httpx to test web request.\r\nwhen i make a redirect response which goes to \"market://details?id=~~\" (android market url)\", KeyError occurred.\r\nI think it is associated with `port` property method.\r\nIs this the intended behavior?\r\n\r\nThank you.\n","hints_text":"Hi @holyachon, I believe this was fixed in a recent release â€” canâ€™t dig up the issue right now but I remember we now use defaults for the port instead of direct key access.\r\n\r\nCan you upgrade to the latest version and confirm this is now resolved?\nhi @florimondmanca , thank you for your quick reply :)\r\nI tested same case with `httpx==0.11.1`, but same error occurs.\r\n\r\ni made a redirect response which goes to \"market://test\", and error trace is below.\r\n\r\n```\r\n  File \"/Users/sym/.pyenv/versions/workbox/lib/python3.7/site-packages/httpx/models.py\", line 148, in port\r\n    return {\"https\": 443, \"http\": 80}[self.scheme]\r\nKeyError: 'market'\r\n```\nOkay, so this *ought* to error by default since \"market\" isn't a valid HTTP scheme, but it could do so more gracefully, and we ought to allow it to be supported by explicitly mounting a dispatcher class for `market`. (Eg. mentioned in passing at https://github.com/encode/httpx/issues/769#issuecomment-576267046)\r\n\r\nFor example `curl` will fail with `curl: (1) Protocol \"market\" not supported or disabled in libcurl`, and `requests` will fail with `requests.exceptions.InvalidSchema: No connection adapters were found for 'market://details?id=~~'`","created_at":"2020-05-27T19:28:29Z","PASS_TO_PASS":["tests/client/test_redirects.py::test_too_many_redirects[asyncio]","tests/client/test_redirects.py::test_redirect_302[asyncio]","tests/client/test_redirects.py::test_body_redirect[trio]","tests/client/test_redirects.py::test_no_body_redirect[trio]","tests/client/test_redirects.py::test_too_many_redirects_calling_next[asyncio]","tests/client/test_redirects.py::test_cross_subdomain_redirect[asyncio]","tests/client/test_redirects.py::test_fragment_redirect[asyncio]","tests/client/test_redirects.py::test_redirect_301[trio]","tests/client/test_redirects.py::test_can_stream_if_no_redirect[trio]","tests/client/test_redirects.py::test_disallow_redirects[trio]","tests/client/test_redirects.py::test_no_scheme_redirect[asyncio]","tests/client/test_redirects.py::test_too_many_redirects[trio]","tests/client/test_redirects.py::test_can_stream_if_no_redirect[asyncio]","tests/client/test_redirects.py::test_redirect_301[asyncio]","tests/client/test_redirects.py::test_multiple_redirects[trio]","tests/client/test_redirects.py::test_no_redirect[trio]","tests/client/test_redirects.py::test_relative_redirect[trio]","tests/client/test_redirects.py::test_malformed_redirect[trio]","tests/client/test_redirects.py::test_too_many_redirects_calling_next[trio]","tests/client/test_redirects.py::test_cross_domain_redirect[trio]","tests/client/test_redirects.py::test_fragment_redirect[trio]","tests/client/test_redirects.py::test_multiple_redirects[asyncio]","tests/client/test_redirects.py::test_cannot_redirect_streaming_body[trio]","tests/client/test_redirects.py::test_cross_subdomain_redirect[trio]","tests/client/test_redirects.py::test_redirect_303[trio]","tests/client/test_redirects.py::test_redirect_302[trio]","tests/client/test_redirects.py::test_cannot_redirect_streaming_body[asyncio]","tests/client/test_redirects.py::test_redirect_loop[asyncio]","tests/client/test_redirects.py::test_no_scheme_redirect[trio]","tests/client/test_redirects.py::test_same_domain_redirect[asyncio]","tests/client/test_redirects.py::test_redirect_cookie_behavior[asyncio]","tests/client/test_redirects.py::test_redirect_cookie_behavior[trio]","tests/client/test_redirects.py::test_malformed_redirect[asyncio]","tests/client/test_redirects.py::test_disallow_redirects[asyncio]","tests/client/test_redirects.py::test_no_redirect[asyncio]","tests/client/test_redirects.py::test_no_body_redirect[asyncio]","tests/client/test_redirects.py::test_relative_redirect[asyncio]","tests/client/test_redirects.py::test_cross_domain_redirect[asyncio]","tests/client/test_redirects.py::test_same_domain_redirect[trio]","tests/client/test_redirects.py::test_redirect_303[asyncio]","tests/client/test_redirects.py::test_redirect_loop[trio]","tests/client/test_redirects.py::test_body_redirect[asyncio]"],"FAIL_TO_PASS":["tests/client/test_redirects.py::test_redirect_custom_scheme[trio]","tests/client/test_redirects.py::test_redirect_custom_scheme[asyncio]"],"FAIL_TO_FAIL":[],"score":-1,"note":null,"version":"default","spec_dict":{"python":"3.9","pip_packages":["rfc3986[idna2008]<2,>=1.3","httpcore<0.15.0,>=0.14.5","socksio==1.*","h2<5,>=3","rich<13,>=10","hpack<5,>=4.1","hyperframe<7,>=6.1","anyio==3.*","h11<0.13,>=0.11","commonmark<0.10.0,>=0.9.0","hstspreload","brotli","pytest-cov","chardet==5.0.0","types-chardet==5.0.3","mkdocs==1.4.0","mkautodoc==0.2.0","mkdocs-material==8.5.5","build==0.8.0","twine==4.0.1","autoflake==1.4","black==22.8.0","coverage==6.4.4","cryptography==38.0.1","flake8==3.9.2","flake8-bugbear==22.7.1","importlib-metadata==4.13.0","isort==5.10.1","mypy==0.971","types-certifi==2021.10.8.2","pytest==7.1.2","pytest-asyncio==0.19.0","pytest-trio==0.7.0","trio==0.21.0","trio-typing==0.7.0","trustme==0.9.0","uvicorn==0.18.3"],"install":"pip install -e .[brotli,cli,http2,socks,zstd]","test_cmd":"pytest --tb=short --json-report --json-report-file=/pass_report.json -W ignore::DeprecationWarning"}}
{"repo":"encode/httpx","pull_number":1032,"instance_id":"encode__httpx-1032","issue_numbers":["777"],"base_commit":"0f7d644b8dba432c5eec08157947a4e551996fa1","patch":"diff --git a/httpx/_content_streams.py b/httpx/_content_streams.py\n--- a/httpx/_content_streams.py\n+++ b/httpx/_content_streams.py\n@@ -328,7 +328,8 @@ def _iter_fields(\n             else:\n                 yield self.DataField(name=name, value=value)\n \n-        for name, value in files.items():\n+        file_items = files.items() if isinstance(files, typing.Mapping) else files\n+        for name, value in file_items:\n             yield self.FileField(name=name, value=value)\n \n     def iter_chunks(self) -> typing.Iterator[bytes]:\ndiff --git a/httpx/_types.py b/httpx/_types.py\n--- a/httpx/_types.py\n+++ b/httpx/_types.py\n@@ -72,4 +72,4 @@\n     # (filename, file (or text), content_type)\n     Tuple[Optional[str], FileContent, Optional[str]],\n ]\n-RequestFiles = Mapping[str, FileTypes]\n+RequestFiles = Union[Mapping[str, FileTypes], List[Tuple[str, FileTypes]]]\n","test_patch":"diff --git a/tests/test_content_streams.py b/tests/test_content_streams.py\n--- a/tests/test_content_streams.py\n+++ b/tests/test_content_streams.py\n@@ -204,3 +204,50 @@ async def test_empty_request():\n def test_invalid_argument():\n     with pytest.raises(TypeError):\n         encode(123)\n+\n+\n+@pytest.mark.asyncio\n+async def test_multipart_multiple_files_single_input_content():\n+    files = [\n+        (\"file\", io.BytesIO(b\"<file content 1>\")),\n+        (\"file\", io.BytesIO(b\"<file content 2>\")),\n+    ]\n+    stream = encode(files=files, boundary=b\"+++\")\n+    sync_content = b\"\".join([part for part in stream])\n+    async_content = b\"\".join([part async for part in stream])\n+\n+    assert stream.can_replay()\n+    assert stream.get_headers() == {\n+        \"Content-Length\": \"271\",\n+        \"Content-Type\": \"multipart/form-data; boundary=+++\",\n+    }\n+    assert sync_content == b\"\".join(\n+        [\n+            b\"--+++\\r\\n\",\n+            b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n+            b\"Content-Type: application/octet-stream\\r\\n\",\n+            b\"\\r\\n\",\n+            b\"<file content 1>\\r\\n\",\n+            b\"--+++\\r\\n\",\n+            b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n+            b\"Content-Type: application/octet-stream\\r\\n\",\n+            b\"\\r\\n\",\n+            b\"<file content 2>\\r\\n\",\n+            b\"--+++--\\r\\n\",\n+        ]\n+    )\n+    assert async_content == b\"\".join(\n+        [\n+            b\"--+++\\r\\n\",\n+            b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n+            b\"Content-Type: application/octet-stream\\r\\n\",\n+            b\"\\r\\n\",\n+            b\"<file content 1>\\r\\n\",\n+            b\"--+++\\r\\n\",\n+            b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n',\n+            b\"Content-Type: application/octet-stream\\r\\n\",\n+            b\"\\r\\n\",\n+            b\"<file content 2>\\r\\n\",\n+            b\"--+++--\\r\\n\",\n+        ]\n+    )\n","problem_statement":"Support for multiple files per POST field\n```\r\nasync def http_upload():\r\n    async with httpx.AsyncClient(verify=False) as client:\r\n        data_path = os.path.join(PARENT_PATH, 'data_file/blob/data')\r\n        index_path = os.path.join(PARENT_PATH, 'data_file/blob/index')\r\n        files = {\r\n            \"upload_file\": [\r\n                open(data_path, 'rb'),\r\n                open(index_path, 'rb'),\r\n            ]\r\n        }\r\n        # files = [\r\n        #     (\"upload_file\", open(data_path, 'rb')),\r\n        #     (\"upload_file\", open(index_path, 'rb'))\r\n        # ]\r\n        params = {\r\n            \"requestId\": \"10001\",\r\n            \"sdkVersion\": \"V1.2.3\",\r\n            \"area\": \"CH\"\r\n        }\r\n\r\n        response = await session.post(url, data=params, files=files)\r\n```\r\n\r\n```console\r\nself = <httpx.content_streams.MultipartStream.FileField object at 0x7f503c22ea60>\r\n\r\n    def render_data(self) -> bytes:\r\n        if isinstance(self.file, str):\r\n            content = self.file\r\n        else:\r\n>           content = self.file.read()\r\nE           AttributeError: 'list' object has no attribute 'read'\r\n\r\nor\r\n    def iter_fields(\r\n        self, data: dict, files: dict\r\n    ) -> typing.Iterator[typing.Union[\"FileField\", \"DataField\"]]:\r\n        for name, value in data.items():\r\n            if isinstance(value, (list, dict)):\r\n                for item in value:\r\n                    yield self.DataField(name=name, value=item)\r\n            else:\r\n                yield self.DataField(name=name, value=value)\r\n\r\n>       for name, value in files.items():\r\nE       AttributeError: 'list' object has no attribute 'items'\r\n```\r\n\r\nExcuse me, how should I useã€‚\n","hints_text":"You should read the manual https://www.python-httpx.org/advanced/#multipart-file-encoding\nHi, not sure was the problem was exactly, but going to close this as resolved for now. If there's anything unclear/missing in the docs relative to your problem, feel free to ping back here! Thanks.\nIt seems to me the OP's problem was the same I'm facing right now in that I'm trying to replicate what is described in the `requests` docs here: https://2.python-requests.org/en/master/user/advanced/#post-multiple-multipart-encoded-files\r\nThe `httpx` docs @j178 pointed to only seem to describe posting a single file (which works exactly as for `requests`). However, once multiple files need to be uploaded, `requests` stops taking a `dict` and uses a `list` instead, as a `dict` can't use the same key multiple times.\r\nThe question now would be how, if at all, this behavior of the `requests` library could be replicated in `httpx`.\n> You should read the manual https://www.python-httpx.org/advanced/#multipart-file-encoding\r\n\r\nUpload multiple files at once, not one.Can't HTTPX solve it?\n> Hi, not sure was the problem was exactly, but going to close this as resolved for now. If there's anything unclear/missing in the docs relative to your problem, feel free to ping back here! Thanks.\r\n\r\nUpload multiple files at once, not one.Can't HTTPX solve it?\r\nThe problem is not solved, why is it closed?\r\nJust like requests: https://2.python-requests.org/en/master/user/advanced/#post-multiple-multipart-encoded-files\n@ysq1222 Reopened, I think itâ€™s clearer now what this is about: uploading multiple files for a given POST field using HTTPX (we only support 1 file per file right now).\r\n\r\nThat last link is particularly helpful, especially because it shows what the API should look like for such a feature, i.e. a list of file dicts (which is a reasonable API I guess, even though the typing for `files` is already quite involved).\r\n\r\nSince itâ€™s supported by Requests I donâ€™t see why we shouldnâ€™t support it. :)\r\n\r\nAt this point, I imagine any PRs towards resolving this are much welcome? ðŸ˜„\nEdited the issue description to better reflect the need here. ðŸ‘\nSo, I think we also want to support the \"either a dict, or a two-tuple of items\" for the `data=...` case too.\r\n\r\nIe, this works in requests, but not in httpx...\r\n\r\n```python\r\nimport requests\r\n\r\nurl = 'https://httpbin.org/post'\r\nr = requests.post(url, data=[(\"a\", \"1\"), (\"a\", \"2\")])\r\nprint(r.text)\r\n```\r\n\r\nIn both cases we want to change how we iterate over the items in `data`/`files`...\r\n\r\nhttps://github.com/encode/httpx/blob/b3db9ff0b6554ed3a48ff912682f4a7d10c3f3f8/httpx/_content_streams.py#L293\r\n\r\nEg... \r\n\r\n```python\r\ndata_items = data.items() if isinstance(data, dict) else data\r\nfiles_items = files.items() if isinstance(files, dict) else files\r\nfor name, value in data_items:\r\n    ...\r\nfor name, value in files_items:\r\n    ...\r\n```\r\n\n> Reopened\r\n\r\nThanks! Great to see quick progress here now :D\r\n\r\n> That last link is particularly helpful\r\n\r\nYou're welcome! Oh. Wait. ðŸ˜‰\n> @ysq1222 Reopened, I think itâ€™s clearer now what this is about: uploading multiple files for a given POST field using HTTPX (we only support 1 file per file right now).\r\n> \r\n> That last link is particularly helpful, especially because it shows what the API should look like for such a feature, i.e. a list of file dicts (which is a reasonable API I guess, even though the typing for `files` is already quite involved).\r\n> \r\n> Since itâ€™s supported by Requests I donâ€™t see why we shouldnâ€™t support it. :)\r\n> \r\n> At this point, I imagine any PRs towards resolving this are much welcome?\r\n\r\nWill it be supported in the next version?\nCan someone point me where to look in the codebase if tackling this issue?\nHi @tegkhanna ðŸ‘‹ you can look at `MultipartStream` in `._content_streams.py`. There should be various hints upper in this thread too.\nThanks @florimondmanca! I will get to it straight away! \nIs there any other site similar to httpbin.org?\r\nI made some changes and they didn't appear to be working. Tested everything and then realized that httpbin.org is not sending the right response. When adding multiple files to the same input, it just sends back the first filename. Checked the same with ```requests``` as given in the last link by @ysq1222 and got the same result. Just the name of the first file.\nNevermind. Checked using https://ptsv2.com/ and it worked like a charm!\r\n\r\nShould I add support for this as well as mentioned by @tomchristie? \r\n> So, I think we also want to support the \"either a dict, or a two-tuple of items\" for the `data=...` case too.\r\n> \r\n> Ie, this works in requests, but not in httpx...\r\n> \r\n> ```python\r\n> import requests\r\n> \r\n> url = 'https://httpbin.org/post'\r\n> r = requests.post(url, data=[(\"a\", \"1\"), (\"a\", \"2\")])\r\n> print(r.text)\r\n> ```\r\n\nAdded a pull request:\r\nhttps://github.com/encode/httpx/pull/891","created_at":"2020-06-24T14:24:35Z","PASS_TO_PASS":["tests/test_content_streams.py::test_iterator_content","tests/test_content_streams.py::test_aiterator_content","tests/test_content_streams.py::test_urlencoded_content","tests/test_content_streams.py::test_json_content","tests/test_content_streams.py::test_bytes_content","tests/test_content_streams.py::test_multipart_data_and_files_content","tests/test_content_streams.py::test_empty_content","tests/test_content_streams.py::test_empty_request","tests/test_content_streams.py::test_invalid_argument","tests/test_content_streams.py::test_multipart_files_content","tests/test_content_streams.py::test_base_content"],"FAIL_TO_PASS":["tests/test_content_streams.py::test_multipart_multiple_files_single_input_content"],"FAIL_TO_FAIL":[],"score":-1,"note":null,"version":"default","spec_dict":{"python":"3.9","pip_packages":["rfc3986[idna2008]<2,>=1.3","httpcore<0.15.0,>=0.14.5","socksio==1.*","h2<5,>=3","rich<13,>=10","hpack<5,>=4.1","hyperframe<7,>=6.1","anyio==3.*","h11<0.13,>=0.11","commonmark<0.10.0,>=0.9.0","hstspreload","brotli","pytest-cov","chardet==5.0.0","types-chardet==5.0.3","mkdocs==1.4.0","mkautodoc==0.2.0","mkdocs-material==8.5.5","build==0.8.0","twine==4.0.1","autoflake==1.4","black==22.8.0","coverage==6.4.4","cryptography==38.0.1","flake8==3.9.2","flake8-bugbear==22.7.1","importlib-metadata==4.13.0","isort==5.10.1","mypy==0.971","types-certifi==2021.10.8.2","pytest==7.1.2","pytest-asyncio==0.19.0","pytest-trio==0.7.0","trio==0.21.0","trio-typing==0.7.0","trustme==0.9.0","uvicorn==0.18.3"],"install":"pip install -e .[brotli,cli,http2,socks,zstd]","test_cmd":"pytest --tb=short --json-report --json-report-file=/pass_report.json -W ignore::DeprecationWarning"}}
{"repo":"pydantic/pydantic","pull_number":2064,"instance_id":"pydantic__pydantic-2064","issue_numbers":["2024"],"base_commit":"78934db63169bf6bc661b2c63f61f996bea5deff","patch":"diff --git a/docs/examples/exporting_models_json_encoders_merge.py b/docs/examples/exporting_models_json_encoders_merge.py\nnew file mode 100644\n--- /dev/null\n+++ b/docs/examples/exporting_models_json_encoders_merge.py\n@@ -0,0 +1,24 @@\n+from datetime import datetime, timedelta\n+from pydantic import BaseModel\n+from pydantic.json import timedelta_isoformat\n+\n+\n+class BaseClassWithEncoders(BaseModel):\n+    dt: datetime\n+    diff: timedelta\n+\n+    class Config:\n+        json_encoders = {\n+            datetime: lambda v: v.timestamp()\n+        }\n+\n+\n+class ChildClassWithEncoders(BaseClassWithEncoders):\n+    class Config:\n+        json_encoders = {\n+            timedelta: timedelta_isoformat\n+        }\n+\n+\n+m = ChildClassWithEncoders(dt=datetime(2032, 6, 1), diff=timedelta(hours=100))\n+print(m.json())\ndiff --git a/pydantic/main.py b/pydantic/main.py\n--- a/pydantic/main.py\n+++ b/pydantic/main.py\n@@ -170,13 +170,19 @@ def prepare_field(cls, field: 'ModelField') -> None:\n \n \n def inherit_config(self_config: 'ConfigType', parent_config: 'ConfigType') -> 'ConfigType':\n+    namespace = {}\n     if not self_config:\n         base_classes = (parent_config,)\n     elif self_config == parent_config:\n         base_classes = (self_config,)\n     else:\n         base_classes = self_config, parent_config  # type: ignore\n-    return type('Config', base_classes, {})\n+        namespace['json_encoders'] = {\n+            **getattr(parent_config, 'json_encoders', {}),\n+            **getattr(self_config, 'json_encoders', {}),\n+        }\n+\n+    return type('Config', base_classes, namespace)\n \n \n EXTRA_LINK = 'https://pydantic-docs.helpmanual.io/usage/model_config/'\n","test_patch":"diff --git a/tests/test_json.py b/tests/test_json.py\n--- a/tests/test_json.py\n+++ b/tests/test_json.py\n@@ -170,6 +170,35 @@ class Config:\n     assert m.json() == '{\"x\": \"P0DT0H2M3.000000S\"}'\n \n \n+def test_json_encoder_simple_inheritance():\n+    class Parent(BaseModel):\n+        dt: datetime.datetime = datetime.datetime.now()\n+        timedt: datetime.timedelta = datetime.timedelta(hours=100)\n+\n+        class Config:\n+            json_encoders = {datetime.datetime: lambda _: 'parent_encoder'}\n+\n+    class Child(Parent):\n+        class Config:\n+            json_encoders = {datetime.timedelta: lambda _: 'child_encoder'}\n+\n+    assert Child().json() == '{\"dt\": \"parent_encoder\", \"timedt\": \"child_encoder\"}'\n+\n+\n+def test_json_encoder_inheritance_override():\n+    class Parent(BaseModel):\n+        dt: datetime.datetime = datetime.datetime.now()\n+\n+        class Config:\n+            json_encoders = {datetime.datetime: lambda _: 'parent_encoder'}\n+\n+    class Child(Parent):\n+        class Config:\n+            json_encoders = {datetime.datetime: lambda _: 'child_encoder'}\n+\n+    assert Child().json() == '{\"dt\": \"child_encoder\"}'\n+\n+\n def test_custom_encoder_arg():\n     class Model(BaseModel):\n         x: datetime.timedelta\n","problem_statement":"json_encoders inheritance\n# Feature Request\r\n\r\nCurrently, defining `json_encoders` in child classes completely overrides the one defined from the parent classes:\r\n```py\r\nfrom datetime import datetime, timedelta\r\nfrom pydantic import BaseModel\r\n\r\nclass A(BaseModel):\r\n    dt: datetime = datetime.now()\r\n    class Config:\r\n        json_encoders = {datetime: lambda _: \"encoded_from_A\"}\r\n\r\nprint(A().json())\r\n#> {\"dt\": \"encoded_from_A\"}\r\nclass B(A):\r\n    timedt: timedelta = timedelta(hours=100)\r\n    class Config:\r\n        json_encoders = {timedelta: lambda _: \"encoded_from_B\"}\r\n\r\nprint(B().json())\r\n#> {\"dt\": \"2020-10-23T01:11:20.613624\", \"timedt\": \"encoded_from_B\"}\r\n\r\n```\r\n\r\nI think it would be handy to merge the JSON encoders with the one defined in the parent ones, thus the result would be:\r\n```py\r\nprint(B().json())\r\n#> {\"dt\": \"encoded_from_A\", \"timedt\": \"encoded_from_B\"}\r\n```\r\n\r\nAs an extension, it should still be possible to override the parent ones:\r\n```py\r\nclass Bbis(A):\r\n    timedt: timedelta = timedelta(hours=100)\r\n\r\n    class Config:\r\n        json_encoders = {\r\n            datetime: lambda _: \"encoded_from_Bbis\",\r\n            timedelta: lambda _: \"encoded_from_Bbis\",\r\n        }\r\n\r\nprint(Bbis().json()) \r\n#> {\"dt\": \"encoded_from_Bbis\", \"timedt\": \"encoded_from_Bbis\"}\r\n```\r\n\r\nI'm eager to implement this feature if you think it's worth it :smile: \n","hints_text":"","created_at":"2020-10-28T18:06:57Z","PASS_TO_PASS":["tests/test_json.py::test_iso_timedelta[input0-P12DT0H0M34.000056S]","tests/test_json.py::test_encoding[input13-\"2032-01-01T01:01:00\"]","tests/test_json.py::test_encoding[input3-\"#010c7b\"]","tests/test_json.py::test_encoding[^regex$-\"^regex$\"]","tests/test_json.py::test_encoding[input9-\"192.168.0.0/24\"]","tests/test_json.py::test_encoding[input5-\"\"]","tests/test_json.py::test_encoding[input0-\"ebcdab58-6eb8-46fb-a190-d07a33e9eac8\"]","tests/test_json.py::test_encode_dataclass","tests/test_json.py::test_encoding[input7-\"\"]","tests/test_json.py::test_custom_decode_encode","tests/test_json.py::test_invalid_model","tests/test_json.py::test_encoding[input23-{\"a\": \"b\", \"c\": \"d\"}]","tests/test_json.py::test_custom_encoder","tests/test_json.py::test_model_encoding","tests/test_json.py::test_encode_custom_root","tests/test_json.py::test_encoding[input22-12.34]","tests/test_json.py::test_encoding[input14-\"2032-01-01T01:01:00+00:00\"]","tests/test_json.py::test_encode_pydantic_dataclass","tests/test_json.py::test_encoding[<genexpr>-[0, 1, 2, 3]]","tests/test_json.py::test_encoding[input2-\"black\"]","tests/test_json.py::test_encoding[MyEnum.foo-\"bar\"]","tests/test_json.py::test_encoding[input17-1036834.000056]","tests/test_json.py::test_encoding[input10-\"2001:db00::/120\"]","tests/test_json.py::test_path_encoding","tests/test_json.py::test_encoding[input6-\"**********\"]","tests/test_json.py::test_encoding[input19-[1, 2, 3]]","tests/test_json.py::test_subclass_custom_encoding","tests/test_json.py::test_encoding[input8-\"::1:0:1\"]","tests/test_json.py::test_encoding[input4-\"**********\"]","tests/test_json.py::test_encoding[input1-\"192.168.0.1\"]","tests/test_json.py::test_iso_timedelta[input1-P1001DT1H2M3.654321S]","tests/test_json.py::test_json_encoder_inheritance_override","tests/test_json.py::test_encoding[input18-[1, 2, 3]]","tests/test_json.py::test_subclass_encoding","tests/test_json.py::test_encoding[input11-\"192.168.0.0/24\"]","tests/test_json.py::test_encoding[this is bytes-\"this is bytes\"]","tests/test_json.py::test_custom_iso_timedelta","tests/test_json.py::test_encoding[input15-\"2032-01-01T00:00:00\"]","tests/test_json.py::test_encoding[input12-\"2001:db00::/120\"]","tests/test_json.py::test_encoding[input16-\"12:34:56\"]","tests/test_json.py::test_custom_encoder_arg"],"FAIL_TO_PASS":["tests/test_json.py::test_json_encoder_simple_inheritance"],"FAIL_TO_FAIL":[],"score":-1,"note":null,"version":"default","spec_dict":{"python":"3.9","install":"","pip_packages":["Cython==0.29.21;sys_platform!='win32'","devtools==0.6.1","email-validator==1.1.2","dataclasses","typing-extensions","python-dotenv==0.15.0","pydantic_core","annotated-types>=0.4.0"],"test_cmd":"pytest --tb=short --json-report --json-report-file=/pass_report.json -W ignore::DeprecationWarning"}}
